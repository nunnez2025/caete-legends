import { AnyCard } from './brazilian-folklore-cards';

export type GamePhase = 'draw' | 'main' | 'battle' | 'end';
export type BattleResult = 'victory' | 'defeat' | 'draw';

export interface GameStats {
  totalGamesPlayed: number;
  winRate: number;
  averageGameTime: number;
  favoriteCard: string;
  longestWinStreak: number;
  totalDamageDealt: number;
  totalHealingDone: number;
  perfectGames: number; // Vit√≥rias sem perder LP
}

export interface BattleEffect {
  id: string;
  name: string;
  description: string;
  duration: number; // turnos
  target: 'player' | 'enemy' | 'field' | 'all';
  type: 'buff' | 'debuff' | 'neutral';
  icon: string;
}

export interface CreatureInstance extends AnyCard {
  instanceId: string;
  summoned: boolean;
  canAttack: boolean;
  attackedThisTurn: boolean;
  currentAttack: number;
  currentDefense: number;
  effects: BattleEffect[];
  position: number;
}

export class AdvancedGameEngine {
  // Sistema de combo
  static calculateComboMultiplier(cardsPlayed: AnyCard[]): number {
    if (cardsPlayed.length < 2) return 1;

    // Combo por elemento
    const elements = cardsPlayed.map(c => c.attribute).filter(Boolean);
    const elementCounts = elements.reduce((acc, el) => {
      acc[el] = (acc[el] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    const maxElementCount = Math.max(...Object.values(elementCounts));
    
    // Combo por regi√£o
    const regions = cardsPlayed.map(c => c.region).filter(Boolean);
    const regionCounts = regions.reduce((acc, reg) => {
      acc[reg] = (acc[reg] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    const maxRegionCount = Math.max(...Object.values(regionCounts));

    // Calcular multiplicador
    let multiplier = 1;
    if (maxElementCount >= 3) multiplier += 0.5;
    if (maxRegionCount >= 2) multiplier += 0.3;
    if (cardsPlayed.length >= 4) multiplier += 0.2;

    return Math.min(multiplier, 2.5); // Cap no multiplicador
  }

  // Sistema de chain de ataques
  static calculateChainDamage(attackingCreatures: CreatureInstance[]): number {
    if (attackingCreatures.length <= 1) return 0;

    const baseDamage = attackingCreatures.reduce((sum, c) => sum + c.attack, 0);
    const chainBonus = (attackingCreatures.length - 1) * 200;
    
    return Math.floor(baseDamage * 0.1 + chainBonus);
  }

  // Sistema de elementos
  static getElementalAdvantage(attacker: string, defender: string): number {
    const advantages: Record<string, string[]> = {
      'Fogo': ['Floresta', 'Vento'],
      '√Ågua': ['Fogo', 'Terra'],
      'Floresta': ['√Ågua', 'Terra'],
      'Terra': ['Vento', 'Sombra'],
      'Vento': ['√Ågua', 'Esp√≠rito'],
      'Sombra': ['Luz', 'Esp√≠rito'],
      'Esp√≠rito': ['Sombra', 'Fogo'],
      'Luz': ['Sombra', 'Esp√≠rito']
    };

    if (advantages[attacker]?.includes(defender)) {
      return 1.3; // 30% de b√¥nus
    } else if (advantages[defender]?.includes(attacker)) {
      return 0.7; // 30% de penalidade
    }
    
    return 1.0; // Neutro
  }

  // Sistema de evolu√ß√£o de cartas
  static canEvolveCard(card: AnyCard, field: CreatureInstance[]): boolean {
    if (card.type !== 'Criatura') return false;

    // Verificar se h√° cartas base no campo
    const baseCards = field.filter(c => 
      c && c.attribute === card.attribute && c.level < card.level
    );

    return baseCards.length > 0;
  }

  // Calcular dano de batalha
  static calculateBattleDamage(
    attacker: CreatureInstance, 
    defender: CreatureInstance
  ): { attackerDamage: number; defenderDamage: number; effects: string[] } {
    const elementalMod = this.getElementalAdvantage(attacker.attribute || '', defender.attribute || '');
    
    const attackerDamage = Math.max(0, Math.floor(attacker.currentAttack * elementalMod) - defender.currentDefense);
    const defenderDamage = Math.max(0, defender.currentAttack - attacker.currentDefense);

    const effects: string[] = [];
    
    if (elementalMod > 1) {
      effects.push(`‚ö° Vantagem Elemental! +${Math.floor((elementalMod - 1) * 100)}% dano`);
    } else if (elementalMod < 1) {
      effects.push(`üõ°Ô∏è Resist√™ncia Elemental! ${Math.floor((1 - elementalMod) * 100)}% menos dano`);
    }

    return { attackerDamage, defenderDamage, effects };
  }

  // Sistema de AI estrat√©gica
  static evaluateGameState(
    playerField: CreatureInstance[],
    enemyField: CreatureInstance[],
    playerLP: number,
    enemyLP: number,
    difficulty: string
  ): 'aggressive' | 'defensive' | 'balanced' | 'desperate' {
    const playerPower = playerField.reduce((sum, c) => sum + (c?.attack || 0), 0);
    const enemyPower = enemyField.reduce((sum, c) => sum + (c?.attack || 0), 0);
    
    const lpRatio = enemyLP / playerLP;
    const powerRatio = enemyPower / Math.max(playerPower, 1);

    // IA desesperada quando com pouca vida
    if (enemyLP < 2000) return 'desperate';
    
    // Estrat√©gia baseada na dificuldade
    switch (difficulty) {
      case 'Lend√°rio':
        if (lpRatio < 0.6 || powerRatio < 0.7) return 'aggressive';
        if (lpRatio > 1.5 && powerRatio > 1.3) return 'defensive';
        return 'balanced';
        
      case 'Dif√≠cil':
        if (lpRatio < 0.8) return 'aggressive';
        if (lpRatio > 1.2) return 'defensive';
        return 'balanced';
        
      default:
        return Math.random() > 0.5 ? 'balanced' : 'aggressive';
    }
  }

  // Calcular prioridade de cartas para IA
  static calculateCardPriority(
    card: AnyCard,
    gameState: any,
    strategy: string
  ): number {
    let priority = 0;

    // Prioridade base por tipo
    if (card.type === 'Criatura') {
      priority += card.attack + card.defense;
      
      // B√¥nus por raridade
      const rarityBonus = {
        'Comum': 0,
        'Rara': 200,
        'Super Rara': 400,
        'Ultra Rara': 600,
        'Lend√°ria': 800,
        'M√≠tica': 1000
      };
      priority += rarityBonus[card.rarity] || 0;
    } else if (card.type === 'Magia') {
      priority += 300; // Magias s√£o sempre √∫teis
      
      // B√¥nus estrat√©gico
      if (strategy === 'aggressive') priority += 200;
      if (strategy === 'desperate') priority += 400;
    }

    // Penalidade por custo alto
    priority -= card.manaCost * 50;

    // B√¥nus por situa√ß√£o espec√≠fica
    if (strategy === 'defensive' && card.type === 'Criatura') {
      priority += card.defense * 0.5;
    }

    return Math.max(0, priority);
  }
}

// Efeitos especiais das cartas
export const cardEffects = {
  // Efeitos de criaturas
  saci_effect: (card: CreatureInstance, gameState: any) => {
    return {
      onSummon: () => ({
        message: "üå™Ô∏è Saci embaralhou uma carta do oponente!",
        effect: () => {
          // Embaralhar carta aleat√≥ria da m√£o do oponente no deck
        }
      }),
      onAttack: () => ({
        message: "üí® Saci ataca com velocidade do vento!",
        canAttackDirectly: true,
        damageModifier: 0.5
      })
    };
  },

  boitata_effect: (card: CreatureInstance, gameState: any) => {
    return {
      onSummon: () => ({
        message: "üêçüî• Boitat√° purifica o campo com fogo sagrado!",
        effect: () => {
          // Destruir todas as magias e armadilhas
        }
      }),
      passive: () => ({
        message: "üî• Imune a magias de √Ågua",
        immuneTo: ['√Ågua']
      })
    };
  },

  cuca_effect: (card: CreatureInstance, gameState: any) => {
    return {
      onSummon: () => ({
        message: "üßô‚Äç‚ôÄÔ∏è Cuca rouba o controle de uma criatura!",
        effect: () => {
          // Roubar controle de criatura inimiga
        }
      })
    };
  },

  iara_effect: (card: CreatureInstance, gameState: any) => {
    return {
      passive: () => ({
        message: "üßú‚Äç‚ôÄÔ∏è Iara fortalece criaturas aqu√°ticas",
        fieldBonus: { attribute: '√Ågua', attack: 300, defense: 300 }
      }),
      oncePerTurn: () => ({
        message: "üíô Iara cura com √°guas sagradas",
        healing: 500
      })
    };
  },

  curupira_effect: (card: CreatureInstance, gameState: any) => {
    return {
      onAttacked: () => ({
        message: "üë£ Curupira confunde o atacante!",
        effect: () => {
          // Trocar ATK/DEF at√© o fim do turno
          const temp = card.currentAttack;
          card.currentAttack = card.currentDefense;
          card.currentDefense = temp;
        }
      })
    };
  }
};

// Sistema de conquistas
export interface Achievement {
  id: string;
  name: string;
  description: string;
  icon: string;
  condition: (gameState: any) => boolean;
  reward?: string;
}

export const achievements: Achievement[] = [
  {
    id: 'first_victory',
    name: 'Primeira Vit√≥ria',
    description: 'Ven√ßa seu primeiro duelo',
    icon: 'üèÜ',
    condition: (gameState) => gameState.playerWins >= 1
  },
  {
    id: 'legend_summoner',
    name: 'Invocador de Lendas',
    description: 'Invoque 3 criaturas Lend√°rias em uma partida',
    icon: 'üëë',
    condition: (gameState) => gameState.legendariesSummoned >= 3
  },
  {
    id: 'combo_master',
    name: 'Mestre dos Combos',
    description: 'Execute um combo de 5 cartas',
    icon: '‚ö°',
    condition: (gameState) => gameState.maxCombo >= 5
  },
  {
    id: 'perfect_game',
    name: 'Jogo Perfeito',
    description: 'Ven√ßa sem perder pontos de vida',
    icon: 'üíé',
    condition: (gameState) => gameState.playerWins > 0 && gameState.playerLifePoints === 8000
  },
  {
    id: 'folklore_master',
    name: 'Mestre do Folclore',
    description: 'Ven√ßa 10 duelos consecutivos',
    icon: 'üåü',
    condition: (gameState) => gameState.streak >= 10
  },
  {
    id: 'legendary_challenger',
    name: 'Desafiante Lend√°rio',
    description: 'Ven√ßa na dificuldade Lend√°ria',
    icon: 'üëπ',
    condition: (gameState) => gameState.difficulty === 'Lend√°rio' && gameState.phase === 'victory'
  }
];

// Sistema de deck building inteligente
export class DeckBuilder {
  static createThematicDeck(theme: 'Norte' | 'Nordeste' | 'Sul' | 'Balanced'): string[] {
    // Implementar cria√ß√£o de decks tem√°ticos por regi√£o
    const deck: string[] = [];
    // ... l√≥gica de constru√ß√£o de deck
    return deck;
  }

  static analyzeDeckBalance(deck: string[]): {
    score: number;
    suggestions: string[];
    strengths: string[];
    weaknesses: string[];
  } {
    // Analisar balanceamento do deck
    return {
      score: 85,
      suggestions: ['Adicionar mais criaturas de baixo custo', 'Incluir magias de controle'],
      strengths: ['Boa distribui√ß√£o de elementos', 'Criaturas poderosas'],
      weaknesses: ['Poucas op√ß√µes defensivas', 'Custo m√©dio alto']
    };
  }
}

// Sistema de temporadas e ranking
export interface SeasonData {
  id: string;
  name: string;
  theme: string;
  startDate: Date;
  endDate: Date;
  rewards: {
    bronze: string[];
    silver: string[];
    gold: string[];
    diamond: string[];
    legend: string[];
  };
}

export class RankingSystem {
  static calculateRank(wins: number, losses: number, streak: number): {
    rank: string;
    tier: number;
    points: number;
    nextRankPoints: number;
  } {
    const winRate = wins / Math.max(wins + losses, 1);
    let points = wins * 100 - losses * 50 + streak * 25;
    
    // B√¥nus por win rate
    if (winRate > 0.7) points += 500;
    else if (winRate > 0.5) points += 200;

    let rank = 'Bronze';
    let tier = 1;

    if (points >= 2000) { rank = 'Lenda'; tier = 1; }
    else if (points >= 1500) { rank = 'Diamante'; tier = Math.floor((points - 1500) / 100) + 1; }
    else if (points >= 1000) { rank = 'Ouro'; tier = Math.floor((points - 1000) / 100) + 1; }
    else if (points >= 500) { rank = 'Prata'; tier = Math.floor((points - 500) / 100) + 1; }
    else { rank = 'Bronze'; tier = Math.floor(points / 100) + 1; }

    const nextRankPoints = rank === 'Lenda' ? points : 
      rank === 'Diamante' ? 2000 :
      rank === 'Ouro' ? 1500 :
      rank === 'Prata' ? 1000 : 500;

    return { rank, tier: Math.min(tier, 5), points, nextRankPoints };
  }
}

// Sistema de meteorologia que afeta o jogo
export interface WeatherEffect {
  name: string;
  icon: string;
  description: string;
  effects: {
    element?: string;
    attackBonus?: number;
    defenseBonus?: number;
    manaBonus?: number;
    healingBonus?: number;
  };
}

export const weatherEffects: WeatherEffect[] = [
  {
    name: 'Chuva Amaz√¥nica',
    icon: 'üåßÔ∏è',
    description: 'Criaturas de √Ågua ganham +300 ATK/DEF',
    effects: { element: '√Ågua', attackBonus: 300, defenseBonus: 300 }
  },
  {
    name: 'Sol Escaldante',
    icon: '‚òÄÔ∏è',
    description: 'Criaturas de Fogo ganham +400 ATK, outras perdem -100 DEF',
    effects: { element: 'Fogo', attackBonus: 400 }
  },
  {
    name: 'Vento Forte',
    icon: 'üí®',
    description: 'Criaturas de Vento podem atacar duas vezes',
    effects: { element: 'Vento' }
  },
  {
    name: 'Lua Cheia',
    icon: 'üåï',
    description: 'Criaturas de Sombra ganham +500 ATK durante a noite',
    effects: { element: 'Sombra', attackBonus: 500 }
  },
  {
    name: 'Floresta Densa',
    icon: 'üå≥',
    description: 'Criaturas de Floresta ganham +200 DEF e curam 200 LP por turno',
    effects: { element: 'Floresta', defenseBonus: 200, healingBonus: 200 }
  }
];

// Sistema de eventos especiais
export interface SpecialEvent {
  id: string;
  name: string;
  description: string;
  icon: string;
  trigger: 'turnStart' | 'turnEnd' | 'summon' | 'attack' | 'spell';
  condition: (gameState: any) => boolean;
  effect: (gameState: any) => any;
}

export const specialEvents: SpecialEvent[] = [
  {
    id: 'festival_junino',
    name: 'Festival Junino',
    description: 'Durante os turnos 6-10, todas as criaturas ganham +200 ATK',
    icon: 'üé™',
    trigger: 'turnStart',
    condition: (gameState) => gameState.turnCount >= 6 && gameState.turnCount <= 10,
    effect: (gameState) => ({
      fieldBonus: { attack: 200 },
      message: 'üé™ Festival Junino! Todas as criaturas ficam mais fortes!'
    })
  },
  {
    id: 'eclipse_solar',
    name: 'Eclipse Solar',
    description: 'Criaturas de Sombra ganham +500 ATK/DEF por 3 turnos',
    icon: 'üåë',
    trigger: 'turnStart',
    condition: (gameState) => gameState.turnCount === 8,
    effect: (gameState) => ({
      elementalBonus: { element: 'Sombra', attack: 500, defense: 500, duration: 3 },
      message: 'üåë Eclipse Solar! As sombras se fortalecem!'
    })
  }
];

export default AdvancedGameEngine;